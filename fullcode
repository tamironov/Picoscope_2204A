# --- Created by Tamir Mironov ---
import tkinter as tk
from tkinter import ttk, messagebox, filedialog
from time import time
from ctypes import POINTER, c_int16, c_uint32
import matplotlib.pyplot as plt
import numpy as np
import csv
from enum import IntEnum
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg

# Assuming picosdk and its dependencies are correctly installed and configured
try:
    from picosdk.ps2000 import ps2000
    from picosdk.functions import assert_pico2000_ok
    from picosdk.ctypes_wrapper import C_CALLBACK_FUNCTION_FACTORY
except ImportError:
    messagebox.showerror("Error", "PicoSDK not found. Please ensure it's installed.")
    exit()

# --- PicoScope Related Enums and Functions ---
class Channel(IntEnum):
    PS2000_CHANNEL_A = 0
    PS2000_CHANNEL_B = 1

class PotentialRange(IntEnum):
    PS2000_10MV = 0
    PS2000_20MV = 1
    PS2000_50MV = 2
    PS2000_100MV = 3
    PS2000_200MV = 4
    PS2000_500MV = 5
    PS2000_1V = 6
    PS2000_2V = 7
    PS2000_5V = 8
    PS2000_10V = 9
    PS2000_20V = 10

class TimeUnit(IntEnum):
    FEMTOSECOND = 0
    PICOSECOND = 1
    NANOSECOND = 2
    MICROSECOND = 3
    MILLISECOND = 4
    SECOND = 5

CALLBACK = C_CALLBACK_FUNCTION_FACTORY(
    None, POINTER(POINTER(c_int16)), c_int16, c_uint32, c_int16, c_int16, c_uint32
)

def adc_to_mv(values, range_, bitness=16):
    """Converts ADC values to millivolts."""
    v_ranges = [10, 20, 50, 100, 200, 500, 1_000, 2_000, 5_000, 10_000, 20_000]
    return [(x * v_ranges[range_]) / (2 ** (bitness - 1) - 1) for x in values]

class StreamingDevice:
    def __init__(
        self,
        sample_interval_ns=500,
        potential_range_a=PotentialRange.PS2000_50MV,
        potential_range_b=PotentialRange.PS2000_50MV,
        channels_to_enable=[Channel.PS2000_CHANNEL_A],
        samples_per_request=50000,
    ):
        """Initializes and configures the PicoScope device for streaming."""
        self.device = ps2000.open_unit()
        self.potential_range_a = potential_range_a
        self.potential_range_b = potential_range_b
        self.channels_to_enable = channels_to_enable
        self.samples_per_request = samples_per_request
        self.sample_interval_ns = sample_interval_ns

        # Keep a mapping of channels to ranges for later conversion
        self.mv_ranges = {
            Channel.PS2000_CHANNEL_A: self.potential_range_a,
            Channel.PS2000_CHANNEL_B: self.potential_range_b,
        }

        for ch in channels_to_enable:
            potential_range = self.mv_ranges[ch]
            res = ps2000.ps2000_set_channel(
                self.device.handle, ch, True, True, potential_range
            )
            assert_pico2000_ok(res)

        # Set up a fixed buffer for streaming on the device.
        # This buffer is managed by the PicoSDK driver and prevents memory leaks
        total_samples = 100_000
        res = ps2000.ps2000_run_streaming_ns(
            self.device.handle,
            sample_interval_ns,
            TimeUnit.NANOSECOND,
            total_samples,
            False,
            1,
            samples_per_request,
        )
        assert_pico2000_ok(res)
        
        self.gathering = True

    def close(self):
        """Stops streaming and closes the device handle."""
        ps2000.ps2000_stop(self.device.handle)
        self.device.close()
        self.gathering = False

    def get_latest_data(self):
        """Gets the latest available data chunk from the device's ring buffer."""
        latest_values = {ch: [] for ch in self.channels_to_enable}
        total_gathered = 0
        
        def get_overview_buffers(buffers, _overflow, _triggered_at, _triggered, _auto_stop, n_values):
            nonlocal latest_values, total_gathered
            for i, ch in enumerate(self.channels_to_enable):
                current_values = buffers[i][0:n_values]
                latest_values[ch].extend(current_values)
            total_gathered = n_values

        callback = CALLBACK(get_overview_buffers)
        ps2000.ps2000_get_streaming_last_values(self.device.handle, callback)
        
        # Convert the received ADC values to mV
        mv_latest_values = {}
        for ch, adc_vals in latest_values.items():
            potential_range = self.mv_ranges[ch]
            mv_latest_values[ch] = adc_to_mv(adc_vals, potential_range)
        
        return mv_latest_values, total_gathered

# ---------------- GUI ----------------
class PicoScopeApp:
    def __init__(self, master):
        self.master = master
        master.title("PicoScope Live Streaming")
        master.geometry("1100x950")
        master.resizable(True, False)

        self.style = ttk.Style()
        self.style.theme_use('clam')
        self.style.configure('TFrame', background='#e0e0e0')
        self.style.configure('TLabel', background='#e0e0e0', font=('Segoe UI', 10))
        self.style.configure('TButton', font=('Segoe UI', 10, 'bold'))
        self.style.configure('TCombobox', font=('Segoe UI', 10))
        self.style.configure('TEntry', font=('Segoe UI', 10))
        self.style.configure('TProgressbar', thickness=15)
        self.style.configure('Bold.TLabel', font=('Segoe UI', 10, 'bold'), anchor='center')

        self.streaming_device = None
        self.is_streaming = False
        self.after_id = None
        self.refresh_interval = 5  # Default refresh interval in seconds
        
        # Data buffer for the current refresh interval
        self.current_plot_data = {Channel.PS2000_CHANNEL_A: [], Channel.PS2000_CHANNEL_B: []}
        self.total_samples_in_interval = 0
        self.last_plot_time = time()

        # Plotting variables
        self.fig, self.ax = plt.subplots(figsize=(8, 5))
        self.line_a = None
        self.line_b = None
        self.ref_line_1 = None
        self.ref_line_2 = None
        
        self.create_widgets()
        self.setup_plot()

    def create_widgets(self):
        main_frame = ttk.Frame(self.master, padding="15")
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Left panel for controls
        control_frame = ttk.Frame(main_frame, width=350, borderwidth=2, relief="groove")
        control_frame.pack(side=tk.LEFT, fill=tk.Y, padx=10, pady=10)
        
        # Right panel for plot and results
        display_frame = ttk.Frame(main_frame, borderwidth=2, relief="groove")
        display_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=10, pady=10)

        # Plot frame
        self.plot_frame = ttk.Frame(display_frame)
        self.plot_frame.pack(fill=tk.BOTH, expand=True, pady=10)
        
        # --- Results and Status Frame ---
        bottom_display_frame = ttk.Frame(display_frame)
        bottom_display_frame.pack(fill=tk.X, padx=10, pady=10)

        results_frame = ttk.Frame(bottom_display_frame, padding="10", borderwidth=2, relief="groove")
        results_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 5))
        results_frame.columnconfigure(1, weight=1)

        peak_analysis_frame = ttk.Frame(bottom_display_frame, padding="10", borderwidth=2, relief="groove")
        peak_analysis_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=(5, 0))
        peak_analysis_frame.columnconfigure(1, weight=1)

        pass_fail_frame = ttk.Frame(display_frame, padding="10", borderwidth=2, relief="groove")
        pass_fail_frame.pack(fill=tk.X, padx=10, pady=(5, 10))
        pass_fail_frame.columnconfigure(0, weight=1)

        # --- Measurement Parameters Section ---
        params_frame = ttk.Frame(control_frame, padding="10", borderwidth=2, relief="groove")
        params_frame.pack(fill=tk.X, padx=5, pady=5)
        ttk.Label(params_frame, text="Measurement Parameters", style='Bold.TLabel').pack(pady=5)
        
        ttk.Label(params_frame, text="Sample Interval (ns):").pack(anchor="w")
        self.entry_interval = ttk.Entry(params_frame)
        self.entry_interval.insert(0, "300")
        self.entry_interval.pack(fill=tk.X)
        
        ttk.Label(params_frame, text="Samples per Request:").pack(anchor="w")
        self.entry_samples_req = ttk.Entry(params_frame)
        self.entry_samples_req.insert(0, "50000")
        self.entry_samples_req.pack(fill=tk.X)

        ttk.Label(params_frame, text="Time to Refresh (s):").pack(anchor="w")
        self.entry_refresh_time = ttk.Entry(params_frame)
        self.entry_refresh_time.insert(0, "5")
        self.entry_refresh_time.pack(fill=tk.X)

        # --- Channel and Reference Settings Section ---
        settings_frame = ttk.Frame(control_frame, padding="10", borderwidth=2, relief="groove")
        settings_frame.pack(fill=tk.X, padx=5, pady=5)
        ttk.Label(settings_frame, text="Channel & Reference", style='Bold.TLabel').pack(pady=5)
        
        combo_values = ["10mV", "20mV", "50mV", "100mV", "200mV", "500mV", "1V", "2V", "5V", "10V", "20V"]
        
        self.ch_a_enabled = tk.BooleanVar(value=True)
        ttk.Checkbutton(settings_frame, text="Enable Channel A", variable=self.ch_a_enabled).pack(anchor="w", pady=2)
        self.combo_range_a = ttk.Combobox(settings_frame, values=combo_values, state="readonly")
        self.combo_range_a.set("200mV")
        self.combo_range_a.pack(fill=tk.X, pady=2)

        self.ch_b_enabled = tk.BooleanVar(value=False)
        ttk.Checkbutton(settings_frame, text="Enable Channel B", variable=self.ch_b_enabled).pack(anchor="w", pady=2)
        self.combo_range_b = ttk.Combobox(settings_frame, values=combo_values, state="readonly")
        self.combo_range_b.set("200mV")
        self.combo_range_b.pack(fill=tk.X, pady=2)
        
        self.ref_line_enabled_1 = tk.BooleanVar(value=False)
        ttk.Checkbutton(settings_frame, text="Enable Ref Line 1 (V)", variable=self.ref_line_enabled_1).pack(anchor="w", pady=2)
        self.entry_ref_voltage_1 = ttk.Entry(settings_frame)
        self.entry_ref_voltage_1.insert(0, "0.0")
        self.entry_ref_voltage_1.pack(fill=tk.X, pady=2)
        
        self.ref_line_enabled_2 = tk.BooleanVar(value=False)
        ttk.Checkbutton(settings_frame, text="Enable Ref Line 2 (V)", variable=self.ref_line_enabled_2).pack(anchor="w", pady=2)
        self.entry_ref_voltage_2 = ttk.Entry(settings_frame)
        self.entry_ref_voltage_2.insert(0, "0.0")
        self.entry_ref_voltage_2.pack(fill=tk.X, pady=2)

        # --- Actions and Status Section ---
        actions_frame = ttk.Frame(control_frame, padding="10", borderwidth=2, relief="groove")
        actions_frame.pack(fill=tk.X, padx=5, pady=5)
        ttk.Label(actions_frame, text="Actions and Status", style='Bold.TLabel').pack(pady=5)
        
        self.status_label = ttk.Label(actions_frame, text="", foreground="blue", anchor="center")
        self.status_label.pack(pady=5, fill=tk.X)
        
        self.start_button = ttk.Button(actions_frame, text="Start Live Stream", command=self.start_measurement)
        self.start_button.pack(pady=5, fill=tk.X)

        self.stop_button = ttk.Button(actions_frame, text="Stop", command=self.stop_measurement, state=tk.DISABLED)
        self.stop_button.pack(pady=5, fill=tk.X)
        
        self.export_button = ttk.Button(actions_frame, text="Export to CSV", command=self.export_data_to_csv, state=tk.DISABLED)
        self.export_button.pack(pady=5, fill=tk.X)

        # --- Calculated Values (left side) ---
        ttk.Label(results_frame, text="Calculated Values", style='Bold.TLabel').grid(row=0, column=0, columnspan=2, sticky="ew", padx=5, pady=5)
        
        row_idx = 1
        self.min_val_var = tk.StringVar()
        ttk.Label(results_frame, text="Min Voltage:").grid(row=row_idx, column=0, sticky="w", pady=2, padx=5)
        ttk.Label(results_frame, textvariable=self.min_val_var, font=('Segoe UI', 10, 'bold')).grid(row=row_idx, column=1, sticky="ew", pady=2, padx=5)
        row_idx += 1

        self.max_val_var = tk.StringVar()
        ttk.Label(results_frame, text="Max Voltage:").grid(row=row_idx, column=0, sticky="w", pady=2, padx=5)
        ttk.Label(results_frame, textvariable=self.max_val_var, font=('Segoe UI', 10, 'bold')).grid(row=row_idx, column=1, sticky="ew", pady=2, padx=5)
        row_idx += 1

        self.pk_pk_var = tk.StringVar()
        ttk.Label(results_frame, text="Peak-to-Peak:").grid(row=row_idx, column=0, sticky="w", pady=2, padx=5)
        ttk.Label(results_frame, textvariable=self.pk_pk_var, font=('Segoe UI', 10, 'bold')).grid(row=row_idx, column=1, sticky="ew", pady=2, padx=5)
        row_idx += 1

        self.mean_var = tk.StringVar()
        ttk.Label(results_frame, text="Mean Voltage:").grid(row=row_idx, column=0, sticky="w", pady=2, padx=5)
        ttk.Label(results_frame, textvariable=self.mean_var, font=('Segoe UI', 10, 'bold')).grid(row=row_idx, column=1, sticky="ew", pady=2, padx=5)
        row_idx += 1

        self.rms_var = tk.StringVar()
        ttk.Label(results_frame, text="RMS Voltage:").grid(row=row_idx, column=0, sticky="w", pady=2, padx=5)
        ttk.Label(results_frame, textvariable=self.rms_var, font=('Segoe UI', 10, 'bold')).grid(row=row_idx, column=1, sticky="ew", pady=2, padx=5)
        row_idx += 1
        
        # --- Peak Analysis (right side) ---
        ttk.Label(peak_analysis_frame, text="Peak Analysis", style='Bold.TLabel').grid(row=0, column=0, columnspan=2, sticky="ew", padx=5, pady=5)
        
        row_idx = 1
        self.avg_peak_max_var = tk.StringVar()
        ttk.Label(peak_analysis_frame, text="Avg Max Peak (above Ref 1):").grid(row=row_idx, column=0, sticky="w", pady=2, padx=5)
        ttk.Label(peak_analysis_frame, textvariable=self.avg_peak_max_var, font=('Segoe UI', 10, 'bold')).grid(row=row_idx, column=1, sticky="ew", pady=2, padx=5)
        row_idx += 1

        self.max_peak_var = tk.StringVar()
        ttk.Label(peak_analysis_frame, text="Max Peak Value:").grid(row=row_idx, column=0, sticky="w", pady=2, padx=5)
        ttk.Label(peak_analysis_frame, textvariable=self.max_peak_var, font=('Segoe UI', 10, 'bold')).grid(row=row_idx, column=1, sticky="ew", pady=2, padx=5)
        row_idx += 1

        self.avg_peak_min_var = tk.StringVar()
        ttk.Label(peak_analysis_frame, text="Avg Min Peak (below Ref 2):").grid(row=row_idx, column=0, sticky="w", pady=2, padx=5)
        ttk.Label(peak_analysis_frame, textvariable=self.avg_peak_min_var, font=('Segoe UI', 10, 'bold')).grid(row=row_idx, column=1, sticky="ew", pady=2, padx=5)
        row_idx += 1

        self.min_peak_var = tk.StringVar()
        ttk.Label(peak_analysis_frame, text="Min Peak Value:").grid(row=row_idx, column=0, sticky="w", pady=2, padx=5)
        ttk.Label(peak_analysis_frame, textvariable=self.min_peak_var, font=('Segoe UI', 10, 'bold')).grid(row=row_idx, column=1, sticky="ew", pady=2, padx=5)
        row_idx += 1
        
        # --- PASS/FAIL Status (centered at the bottom) ---
        self.pass_fail_status_var = tk.StringVar()
        self.pass_fail_label = ttk.Label(pass_fail_frame, textvariable=self.pass_fail_status_var, font=('Segoe UI', 12, 'bold'), anchor='center')
        self.pass_fail_label.grid(row=0, column=0, sticky="ew", pady=5)

        help_button = ttk.Button(control_frame, text="Help", command=self.show_help_window)
        help_button.pack(side=tk.BOTTOM, fill=tk.X, padx=5, pady=5)

    def setup_plot(self):
        """Initializes the matplotlib plot and embeds it in the GUI."""
        self.canvas = FigureCanvasTkAgg(self.fig, master=self.plot_frame)
        self.canvas_widget = self.canvas.get_tk_widget()
        self.canvas_widget.pack(fill=tk.BOTH, expand=True)
        
        self.ax.set_xlabel("Time (s)")
        self.ax.set_ylabel("Voltage (mV)")
        self.ax.set_title("Live PicoScope Data")
        self.ax.grid(True)
        self.fig.tight_layout()
        
    def clear_results(self):
        """Clears all result variables."""
        self.min_val_var.set("")
        self.max_val_var.set("")
        self.pk_pk_var.set("")
        self.mean_var.set("")
        self.rms_var.set("")
        self.avg_peak_max_var.set("")
        self.max_peak_var.set("")
        self.avg_peak_min_var.set("")
        self.min_peak_var.set("")
        self.pass_fail_status_var.set("")
        self.pass_fail_label.config(foreground="black")
        
    def update_plot(self):
        """
        Fetches new data and updates the plot and calculations.
        This function now works with a fixed-size buffer to prevent memory leaks.
        """
        if not self.is_streaming:
            return
        
        # Get the latest chunk of data from the device
        latest_data_chunk, num_new_samples = self.streaming_device.get_latest_data()
        
        if num_new_samples > 0:
            # Append new data to the current interval's buffer
            for ch, values in latest_data_chunk.items():
                self.current_plot_data[ch].extend(values)
            self.total_samples_in_interval += num_new_samples

            current_time = time()
            elapsed_time = current_time - self.last_plot_time
            
            # --- THIS IS THE CRITICAL SECTION FOR REFRESHING THE GRAPH ---
            # Check if the refresh interval has elapsed.
            # If so, plot the data and reset the buffer for the next interval.
            if elapsed_time >= self.refresh_interval:
                self.plot_and_calculate_data()
                
                # Clear the buffer and reset the timer for the next interval
                for ch in self.current_plot_data:
                    self.current_plot_data[ch] = []
                self.total_samples_in_interval = 0
                self.last_plot_time = current_time

        # Schedule the next check (e.g., every 100ms)
        self.after_id = self.master.after(100, self.update_plot)

    def plot_and_calculate_data(self):
        """Performs the actual plotting and calculations on the data gathered for the interval."""
        if self.total_samples_in_interval == 0:
            return

        # Get data from the buffer
        all_data = self.current_plot_data
        first_channel_values = list(all_data.values())[0]

        # Use numpy arrays for efficient calculations
        first_channel_array = np.array(first_channel_values)
        
        self.ax.clear()
        self.ax.set_xlabel("Time (s)")
        self.ax.set_ylabel("Voltage (mV)")
        self.ax.set_title("Live PicoScope Data")
        self.ax.grid(True)
        
        # The time axis is based on the data in the current interval's buffer
        sample_interval_sec = self.streaming_device.sample_interval_ns * 1e-9
        time_values_sec = np.arange(0, len(first_channel_array) * sample_interval_sec, sample_interval_sec)
        
        for ch, values in all_data.items():
            label = f"Channel {ch.name[-1:]}"
            self.ax.plot(time_values_sec[:len(values)], values, label=label)

        # Update reference lines
        ref_line_enabled_1 = self.ref_line_enabled_1.get()
        ref_voltage_1_v = 0
        if ref_line_enabled_1:
            try:
                ref_voltage_1_v = float(self.entry_ref_voltage_1.get())
                ref_voltage_1_mv = ref_voltage_1_v * 1000
                self.ax.axhline(y=ref_voltage_1_mv, color='green', linestyle='--', label=f"Ref 1 ({ref_voltage_1_v} V)")
            except ValueError:
                pass

        ref_line_enabled_2 = self.ref_line_enabled_2.get()
        ref_voltage_2_v = 0
        if ref_line_enabled_2:
            try:
                ref_voltage_2_v = float(self.entry_ref_voltage_2.get())
                ref_voltage_2_mv = ref_voltage_2_v * 1000
                self.ax.axhline(y=ref_voltage_2_mv, color='blue', linestyle='--', label=f"Ref 2 ({ref_voltage_2_v} V)")
            except ValueError:
                pass
        
        self.ax.legend()
        self.canvas.draw()
        
        # Perform calculations and update labels
        min_voltage = np.min(first_channel_array)
        max_voltage = np.max(first_channel_array)
        peak_to_peak = max_voltage - min_voltage
        mean_voltage = np.mean(first_channel_array)
        rms_voltage = np.sqrt(np.mean(np.square(first_channel_array)))

        self.min_val_var.set(f"{min_voltage:.2f} mV")
        self.max_val_var.set(f"{max_voltage:.2f} mV")
        self.pk_pk_var.set(f"{peak_to_peak:.2f} mV")
        self.mean_var.set(f"{mean_voltage:.2f} mV")
        self.rms_var.set(f"{rms_voltage:.2f} mV")

        # --- Peak Analysis Logic ---
        if ref_line_enabled_1 or ref_line_enabled_2:
            # Simple peak finding logic (local maxima/minima)
            max_peaks = []
            min_peaks = []
            if len(first_channel_array) > 2:
                # Find local maxima and minima by comparing a point to its neighbors
                max_peaks = first_channel_array[(first_channel_array > np.roll(first_channel_array, 1)) & (first_channel_array > np.roll(first_channel_array, -1))]
                min_peaks = first_channel_array[(first_channel_array < np.roll(first_channel_array, 1)) & (first_channel_array < np.roll(first_channel_array, -1))]

            # Filter max peaks above ref line 1
            peaks_above_ref1 = [p for p in max_peaks if p > ref_voltage_1_mv]
            if peaks_above_ref1:
                avg_max_peak = np.mean(peaks_above_ref1)
                max_peak_value = np.max(peaks_above_ref1)
                self.avg_peak_max_var.set(f"{avg_max_peak:.2f} mV")
                self.max_peak_var.set(f"{max_peak_value:.2f} mV")
            else:
                self.avg_peak_max_var.set("N/A")
                self.max_peak_var.set("N/A")

            # Filter min peaks below ref line 2
            peaks_below_ref2 = [p for p in min_peaks if p < ref_voltage_2_mv]
            if peaks_below_ref2:
                avg_min_peak = np.mean(peaks_below_ref2)
                min_peak_value = np.min(peaks_below_ref2)
                self.avg_peak_min_var.set(f"{avg_min_peak:.2f} mV")
                self.min_peak_var.set(f"{min_peak_value:.2f} mV")
            else:
                self.avg_peak_min_var.set("N/A")
                self.min_peak_var.set("N/A")
        else:
            self.avg_peak_max_var.set("N/A")
            self.max_peak_var.set("N/A")
            self.avg_peak_min_var.set("N/A")
            self.min_peak_var.set("N/A")
        # ------------------------------------

        # --- PASS/FAIL Logic ---
        if ref_line_enabled_1 or ref_line_enabled_2:
            ref_voltage_1_mv = ref_voltage_1_v * 1000
            ref_voltage_2_mv = ref_voltage_2_v * 1000
            
            pass_status = False
            # Pass if max voltage exceeds ref 1 OR min voltage is below ref 2
            if (ref_line_enabled_1 and max_voltage > ref_voltage_1_mv) or \
               (ref_line_enabled_2 and min_voltage < ref_voltage_2_mv):
                pass_status = True
                
            if pass_status:
                self.pass_fail_status_var.set("PASS")
                self.pass_fail_label.config(foreground="green")
            else:
                self.pass_fail_status_var.set("FAIL")
                self.pass_fail_label.config(foreground="red")
        else:
            self.pass_fail_status_var.set("N/A")
            self.pass_fail_label.config(foreground="black")


    def start_measurement(self):
        """Starts the live streaming measurement."""
        self.start_button.config(state=tk.DISABLED)
        self.stop_button.config(state=tk.NORMAL)
        self.export_button.config(state=tk.DISABLED)
        self.clear_results()
        self.status_label.config(text="Initializing PicoScope...", foreground="blue")
        self.master.update_idletasks()

        display_to_enum_map = {
            "10mV": PotentialRange.PS2000_10MV, "20mV": PotentialRange.PS2000_20MV,
            "50mV": PotentialRange.PS2000_50MV, "100mV": PotentialRange.PS2000_100MV,
            "200mV": PotentialRange.PS2000_200MV, "500mV": PotentialRange.PS2000_500MV,
            "1V": PotentialRange.PS2000_1V, "2V": PotentialRange.PS2000_2V,
            "5V": PotentialRange.PS2000_5V, "10V": PotentialRange.PS2000_10V,
            "20V": PotentialRange.PS2000_20V,
        }

        try:
            sample_interval_ns = int(self.entry_interval.get())
            if sample_interval_ns <= 0: raise ValueError("Sample interval must be a positive integer.")
            
            channels_to_enable = []
            if self.ch_a_enabled.get(): channels_to_enable.append(Channel.PS2000_CHANNEL_A)
            if self.ch_b_enabled.get(): channels_to_enable.append(Channel.PS2000_CHANNEL_B)
            if not channels_to_enable: raise ValueError("At least one channel must be enabled.")

            voltage_range_a = display_to_enum_map[self.combo_range_a.get()]
            voltage_range_b = display_to_enum_map[self.combo_range_b.get()]
            samples_per_request = int(self.entry_samples_req.get())
            if samples_per_request <= 0: raise ValueError("Samples per request must be a positive integer.")
            
            refresh_time_sec = int(self.entry_refresh_time.get())
            if refresh_time_sec <= 0: raise ValueError("Refresh time must be a positive integer.")
            self.refresh_interval = refresh_time_sec

        except ValueError as ve:
            messagebox.showerror("Invalid Input", f"Please check your input values:\n{ve}")
            self.status_label.config(text="Input Error!", foreground="red")
            self.start_button.config(state=tk.NORMAL)
            self.stop_button.config(state=tk.DISABLED)
            return

        try:
            self.streaming_device = StreamingDevice(
                sample_interval_ns=sample_interval_ns,
                potential_range_a=voltage_range_a,
                potential_range_b=voltage_range_b,
                channels_to_enable=channels_to_enable,
                samples_per_request=samples_per_request,
            )
            self.is_streaming = True
            self.status_label.config(text="Live streaming...", foreground="green")
            self.master.update_idletasks()
            self.last_plot_time = time()
            # Start the main loop that fetches and plots data
            self.update_plot()

        except Exception as e:
            messagebox.showerror("Error", f"An error occurred: {str(e)}")
            self.status_label.config(text=f"Error: {str(e)}", foreground="red")
            self.stop_measurement()

    def stop_measurement(self):
        """Stops the live streaming measurement."""
        if self.is_streaming:
            self.is_streaming = False
            if self.after_id:
                self.master.after_cancel(self.after_id)
            if self.streaming_device:
                self.streaming_device.close()
            
            self.status_label.config(text="Streaming stopped.", foreground="blue")
            self.start_button.config(state=tk.NORMAL)
            self.stop_button.config(state=tk.DISABLED)
            self.export_button.config(state=tk.NORMAL)

    def export_data_to_csv(self):
        """Exports the acquired data to a CSV file."""
        # Export the data from the last completed refresh interval
        if not self.current_plot_data or self.total_samples_in_interval == 0:
            messagebox.showinfo("No Data", "No data available to export. Please run a measurement first.")
            return

        file_path = filedialog.asksaveasfilename(
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv"), ("All files", "*.*")],
            title="Save Measurement Data"
        )

        if not file_path:
            return

        try:
            with open(file_path, 'w', newline='') as csvfile:
                csv_writer = csv.writer(csvfile)
                header = ["Time (s)"]
                for ch in self.current_plot_data.keys():
                    header.append(f"Voltage {ch.name[-1:]} (mV)")
                csv_writer.writerow(header)
                
                # Get the data from the last completed interval
                all_data = self.current_plot_data
                first_channel_values = list(all_data.values())[0]
                sample_interval_sec = self.streaming_device.sample_interval_ns * 1e-9
                time_values_sec = np.arange(0, len(first_channel_values) * sample_interval_sec, sample_interval_sec)
                
                data_rows = list(zip(time_values_sec, *all_data.values()))
                csv_writer.writerows(data_rows)
            
            messagebox.showinfo("Export Successful", f"Data successfully exported to:\n{file_path}")
        except Exception as e:
            messagebox.showerror("Export Error", f"Failed to export data to CSV:\n{str(e)}")

    def show_help_window(self):
        """Displays a new window with a readme/help text."""
        help_window = tk.Toplevel(self.master)
        help_window.title("Help")
        help_window.geometry("500x450")

        readme_text = """
        PicoScope Live Streaming Application

        Overview:
        This application is designed to interface with a PicoScope device (specifically, a PS2000 series) to perform
        real-time, streaming voltage measurements. It allows you to configure measurement parameters, view the acquired
        data in a live graph, and export the entire dataset to a CSV file.

        The application now uses a fixed-size data buffer, which prevents memory from being consumed indefinitely. This
        fixes the "collapse" issue and ensures the application can run for a very long time without crashing.

        Controls:
        - Sample Interval (ns): The time between consecutive samples. A smaller value means a higher sample rate.
        - Samples per Request: The number of samples requested from the device in each streaming batch.
        - Time to Refresh (s): The time in seconds between each plot update.
        - Enable Channel A/B: Checkboxes to enable or disable the measurement on each channel.
        - Voltage Range: A dropdown menu to select the potential range for each enabled channel.
        - Enable Ref Line 1/2 (V): Checkboxes to add horizontal reference lines to the live graph at a specified voltage.
        - Start Live Stream: Initiates the data acquisition process and begins updating the plot.
        - Stop: Halts the live streaming and enables the 'Export' button.
        - Export to CSV: Saves all the data acquired during the last streaming session to a CSV file.

        Live Plotting and Calculations:
        The plot in the main window is updated every X seconds (based on the 'Time to Refresh' parameter) to show the most recent data. The calculated values and
        peak analysis are updated in real-time based on the data from the current interval.

        Peak Analysis:
        This section identifies local maximum and minimum peaks in the data.
        - It calculates the average voltage of all local maximum peaks that are found above Reference Line 1.
        - It displays the single highest peak value found in the data above Reference Line 1.
        - It calculates the average voltage of all local minimum peaks that are found below Reference Line 2.
        - It displays the single lowest peak value found in the data below Reference Line 2.

        PASS/FAIL Status:
        If one or both reference lines are enabled, the application will perform a real-time test. The status is PASS if the
        maximum voltage exceeds Reference Line 1, or if the minimum voltage falls below Reference Line 2.
        Otherwise, the status is FAIL.
        """

        text_frame = ttk.Frame(help_window)
        text_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)

        scrollbar = ttk.Scrollbar(text_frame)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        readme_widget = tk.Text(text_frame, wrap="word", yscrollcommand=scrollbar.set)
        readme_widget.insert(tk.END, readme_text)
        readme_widget.config(state=tk.DISABLED, font=('Segoe UI', 10))
        readme_widget.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        
        scrollbar.config(command=readme_widget.yview)

        close_button = ttk.Button(help_window, text="Close", command=help_window.destroy)
        close_button.pack(pady=10)


root = tk.Tk()
app = PicoScopeApp(root)
root.mainloop()
